<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Nginx Document 总结（一）</title><link rel="shortcut icon" href="/images/angellist.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">Ritter</a></div><div class="about-me">Hi~ </div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/Ri773r"></span><a href="https://github.com/Ri773r" target="_blank" title="https://github.com/Ri773r">https://github.com/Ri773r</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="610577219@qq.com"></span><span>610577219@qq.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="Sky610577219"></span><span>Sky610577219</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">Nginx Document 总结（一）</div><div class="date">写于2020年05月14日</div><div class="content"><h2 id="Starting-Stopping-and-Reloading-Configuration"><a href="#Starting-Stopping-and-Reloading-Configuration" class="headerlink" title="Starting, Stopping, and Reloading Configuration"></a>Starting, Stopping, and Reloading Configuration</h2><h2 id="启动，停止和重载"><a href="#启动，停止和重载" class="headerlink" title="启动，停止和重载"></a>启动，停止和重载</h2><p>格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s signal</span><br></pre></td></tr></table></figure>
<ul>
<li>stop - 退出</li>
<li>quit - 优雅退出</li>
<li>reload - 重新加载配置文件</li>
<li>reopen - 重新打开日志文件</li>
</ul>
<p>或者借助Unix工具(例如kill)向nginx进程发送指定信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s QUIT 1628</span><br></pre></td></tr></table></figure>

<p>默认情况下，nginx主进程的进程ID将写入目录/usr/local/nginx/logs或/var/run中的nginx.pid文件</p>
<p>主进程支持以下信号：</p>
<ul>
<li>TERM, INT - 退出</li>
<li>QUIT - 优雅退出</li>
<li>HUP - 重新加载配置文件(仅适用于FreeBSD和Linux)</li>
<li>USR1 - 重新打开日志文件</li>
<li>USR2 - 升级可执行文件</li>
<li>WINCH - 优雅关闭工作进程</li>
</ul>
<p>虽然不是必需的，但是也可以通过信号控制单个工作进程。支持的信号是：</p>
<ul>
<li>TERM, INT - 退出</li>
<li>QUIT - 优雅退出</li>
<li>USR1 - 重新打开日志文件</li>
<li>WINCH - 调试异常终止(需要启用<a href="https://nginx.org/en/docs/ngx_core_module.html#debug_points" target="_blank" rel="noopener">debug_points</a>)</li>
</ul>
<hr>
<h2 id="Command-line-parameters-命令行参数"><a href="#Command-line-parameters-命令行参数" class="headerlink" title="Command-line parameters 命令行参数"></a>Command-line parameters 命令行参数</h2><p>nginx 命令支持以下命令行参数：</p>
<ul>
<li>-? | -h 打印命令行工具帮助信息</li>
<li>-c <em>file</em> 指定配置文件</li>
<li>-g <em>directives</em> 设置全局全局配置指令，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -g &quot;pid &#x2F;var&#x2F;run&#x2F;nginx.pid; worker_processes \&#96;sysctl -n hw.ncpu\&#96;;&quot;</span><br></pre></td></tr></table></figure></li>
<li>-p <em>prefix</em>  设置nginx路径前缀，即将保留服务器文件的目录(默认值为/usr/local/nginx)</li>
<li>-s <em>signal</em> 向主进程发送信号，如上</li>
<li>-t 检查配置文件语法是否正确</li>
<li>-T 类似-t参数，但还会向标准输出打印所有配置</li>
<li>-v 打印nginx版本</li>
<li>-V 打印nginx版本，编译器版本和配置参数</li>
</ul>
<hr>
<h2 id="How-nginx-processes-a-request"><a href="#How-nginx-processes-a-request" class="headerlink" title="How nginx processes a request"></a>How nginx processes a request</h2><h2 id="nginx如何处理一个请求"><a href="#nginx如何处理一个请求" class="headerlink" title="nginx如何处理一个请求"></a>nginx如何处理一个请求</h2><h3 id="Name-based-virtual-servers-基于名称的虚拟服务器"><a href="#Name-based-virtual-servers-基于名称的虚拟服务器" class="headerlink" title="Name-based virtual servers 基于名称的虚拟服务器"></a>Name-based virtual servers 基于名称的虚拟服务器</h3><p>以下三个虚拟服务器都在80端口上侦听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此配置中，nginx会用请求头中的”Host”字段去匹配所有<strong>server</strong>的<strong>server_name</strong>，用来确定应该将请求路由到哪个虚拟服务器中。如果”Host”字段值与所有<strong>server</strong>中的<strong>server_name</strong>都不匹配，则会将请求路由到请求端口(当前为80)默认的虚拟服务器。在上面的配置中，默认的虚拟服务器是从上到下配置的第一个<strong>server</strong>。这是nginx的默认行为。你可以使用<strong>listen</strong>指令中的<strong>default_server</strong>参数来明确设置哪个<strong>server</strong>应为默认的虚拟服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80 default_server;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意</em><br>* <em>在0.8.21版本之前请使用<strong>default</strong>参数</em><br>* <em>参数<strong>default_server</strong>是<strong>listen</strong>指令的参数，而不是<strong>server_name</strong>指令的参数</em></p>
<h3 id="How-to-prevent-processing-requests-with-undefined-server-names"><a href="#How-to-prevent-processing-requests-with-undefined-server-names" class="headerlink" title="How to prevent processing requests with undefined server names"></a>How to prevent processing requests with undefined server names</h3><h3 id="如何防止使用未定义的服务器名称处理请求"><a href="#如何防止使用未定义的服务器名称处理请求" class="headerlink" title="如何防止使用未定义的服务器名称处理请求"></a>如何防止使用未定义的服务器名称处理请求</h3><p>如果不允许不带”Host”字段的请求，可以定义仅丢弃指定请求的虚拟服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name &quot;&quot;;</span><br><span class="line">    return      444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面配置虚拟服务器的<strong>server_name</strong>字段为空字符串，该字符串与没有”Host”请求头的请求匹配，返回特殊的nginx非标准代码444，然后关闭连接。  </p>
<p><em>注意</em><br>* <em>从版本0.8.48开始，这是<strong>server_name</strong>的默认设置，因此可以省略<strong>server_name</strong>属性</em><br>* <em>在早期版本中，计算机的主机名用作默认<strong>server_name</strong>值</em></p>
<h3 id="Mixed-name-based-and-IP-based-virtual-servers"><a href="#Mixed-name-based-and-IP-based-virtual-servers" class="headerlink" title="Mixed name-based and IP-based virtual servers"></a>Mixed name-based and IP-based virtual servers</h3><h3 id="基于名称和IP的虚拟服务器"><a href="#基于名称和IP的虚拟服务器" class="headerlink" title="基于名称和IP的虚拟服务器"></a>基于名称和IP的虚拟服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.2:80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，nginx首先会根据<strong>server</strong>块的<strong>listen</strong>指令测试请求中的IP地址和端口。然后，它根据匹配到的<strong>server</strong>块中的<strong>server_name</strong>继续匹配请求头中的”Host”字段。如果找不到对应的<strong>server_name</strong>，则将请求路由至默认虚拟服务器。例如，在192.168.1.1:80端口上接收到的<code>www.example.com</code>请求将由192.168.1.1:80端口的默认服务器(即第一台服务器)处理，因为没有为此端口定义<code>www.example.com</code>。<br>如前所述，<strong>default_server</strong>是<strong>listen</strong>指令的参数，并且可以为不同IP或端口定义不同的默认虚拟服务器。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80;</span><br><span class="line">    server_name example.org www.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.1:80 default_server;</span><br><span class="line">    server_name example.net www.example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      192.168.1.2:80 default_server;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Server-names-服务器名称"><a href="#Server-names-服务器名称" class="headerlink" title="Server names 服务器名称"></a>Server names 服务器名称</h2><p>虚拟服务器名称是由<strong>server_name</strong>指令定义的，用于确定请求的具体路由，可以使用确切名称，通配符名称或正则表达式来定义它们。  </p>
<p>按名称搜索虚拟服务器时，如果名称匹配到多个，则按以下优先级选择第一个匹配：  </p>
<ol>
<li>确切名称</li>
<li>以星号开头的最长通配符名称，例如<code>*.example.org</code></li>
<li>以星号结尾的最长通配符名称，例如<code>mail.*</code></li>
<li>第一个匹配的正则表达式(按在配置文件中出现的顺序)</li>
</ol>
<h3 id="Wildcard-names-通配符名称"><a href="#Wildcard-names-通配符名称" class="headerlink" title="Wildcard names 通配符名称"></a>Wildcard names 通配符名称</h3><p>通配符名称只能在名称的开头或结尾包含星号，例如<code>www.*.example.org</code>和<code>w*.example.org</code>是无效的。但是你可以使用正则表达式指定这些名称，例如<code>~^www\..+\.example\.org$</code>和<code>~^w.*\.example\.org$</code>中，星号可以匹配多个名称部分。<code>*.example.org</code>不仅与<code>www.example.org</code>匹配，而且与<code>www.sub.example.org</code>也匹配。</p>
<p>可以使用格式为<code>.example.org</code>的特殊通配符名称来匹配确切名称<code>example.org</code>和通配符名称<code>*.example.org</code>。</p>
<h3 id="Regular-expressions-names-正则表达式名称"><a href="#Regular-expressions-names-正则表达式名称" class="headerlink" title="Regular expressions names 正则表达式名称"></a>Regular expressions names 正则表达式名称</h3><p>nginx使用的正则表达式与Perl语言(PCRE)使用的正则表达式兼容。要使用正则表达式，<strong>server_name</strong>必须与波浪号字符开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name  ~^www\d+\.example\.net$;</span><br></pre></td></tr></table></figure>
<p>否则将被视为确切名称。如果表达式里面包含星号，将被视为通配符名称。不要忘记设置”^”和”$”锚点，虽然在语法上不是必须的，但在逻辑上是必须的。另外请注意，域名点符号应该用反斜杠(\)转义，包含字符”{“和”}”应该用引号包裹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name &quot;~^(?&lt;name&gt;\w\d&#123;1,3&#125;+)\.example\.net$&quot;;</span><br></pre></td></tr></table></figure>
<p>否则，nginx将在启动时报出以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directive &quot;server_name&quot; is not terminated by &quot;;&quot; in ...</span><br></pre></td></tr></table></figure>
<p>命名的正则表达式捕获组可以在之后用作变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name ~^(www\.)?(?&lt;domain&gt;.+)$;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;sites&#x2F;$domain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PCRE库使用以下语法支持命名捕获：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?&lt;name&gt; Perl5.10兼容语法，自PCRE-7.0起受支持</span><br><span class="line">?&#39;name&#39; Perl5.10兼容语法，自PCRE-7.0起受支持</span><br><span class="line">?P&lt;name&gt; Python兼容语法，自PCRE-4.0起受支持</span><br></pre></td></tr></table></figure>
<p>如果nginx无法启动并显示以下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre_compile() failed: unrecognized character after (?&lt; in ...</span><br></pre></td></tr></table></figure>
<p>这意味着PCRE库较旧，你应该尝试<code>?P&lt;name&gt;</code>语法。捕获分组也可以以数字形式引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name ~^(www\.)?(.+)$;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;sites&#x2F;$2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这种用法应仅限于简单场景(像上面这种)，因为数字参考很容易被覆盖。</p>
<h3 id="Miscellaneous-names-杂项名称"><a href="#Miscellaneous-names-杂项名称" class="headerlink" title="Miscellaneous names 杂项名称"></a>Miscellaneous names 杂项名称</h3><p>如果要求处理请求头中没有”Host”字段的请求，应该指定一个空名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.org www.example.org &quot;&quot;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果虚拟服务器中未定义<strong>server_name</strong>，则nginx使用空名称作为服务器名称。</p>
<p><em>注意</em><br><em>\</em>在0.8.48及以下版本前使用计算机的主机名作为服务器名称*。</p>
<p>如果服务器名称定义为<code>$hostname</code>(0.9.4开始)，则使用计算机的主机名。<br>如果有人使用IP地址而不是服务器名称发出请求，则请求头”Host”字段将包含IP地址，并且可以使用IP地址作为服务器名称来处理请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.org</span><br><span class="line">                www.example.org</span><br><span class="line">                &quot;&quot;</span><br><span class="line">                192.168.1.1</span><br><span class="line">                ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有虚拟服务器示例中，可以看到一个奇怪的名称”_”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line">    return 444;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个名称没有什么特别，它表示未匹配到其他有效<strong>server_name</strong>之外的所有无效域名。同样可以使用其他无效名称，例如”-“和”!@#”。</p>
<p>nginx在0.6.25及以下版本支持特殊名称”*“，该名称被错误地解释为万能名称。它从不用作通用或通配符名称服务器名称。相反，它提供了<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#server_name_in_redirect" target="_blank" rel="noopener">server_name_in_redirect</a>指令现在提供的功能。现在不赞成使用特殊名称”*“，而应该使用<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#server_name_in_redirect" target="_blank" rel="noopener">server_name_in_redirect</a>指令。请注意，无法使用<strong>server_name</strong>指令指定通用名称或默认虚拟服务器。因为这是<strong>listen</strong>指令的属性，而不是<strong>server_name</strong>指令的属性。可以定义监听端口<code>*:80</code>和<code>*:8080</code>的虚拟服务器，并指示其中一个是<code>*:8080</code>的默认虚拟服务器，而另一个是<code>*:80</code>的默认虚拟服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 8080 default_server;</span><br><span class="line">    server_name example.net;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optimization-优化"><a href="#Optimization-优化" class="headerlink" title="Optimization 优化"></a>Optimization 优化</h3><p>确切名称，以星号开头的通配符名称和以星号结尾的通配符名称存储在绑定到侦听端口的三个哈希表中。哈希表的大小在配置阶段进行了优化，以便可以找到CPU缓存未命中最少的名称。设置哈希表的详细信息在单独的<a href="https://nginx.org/en/docs/hash.html" target="_blank" rel="noopener">文档</a>中提供。</p>
<p>首先搜索确切名称哈希表。如果未找到名称，则搜索具有以星号开头的通配符名称的哈希表。如果没有找到，则搜索带有通配符名称以星号结尾的哈希表。</p>
<p>搜索通配符名称哈希表比搜索精确名称哈希表要慢，因为名称是按域部分搜索的。请注意，特殊的通配符格式<code>.example.org</code>存储在通配符名称哈希表中，而不存储在确切的名称哈希表中。</p>
<p>正则表达式是按顺序测试的，因此是最慢的方法，并且不可缩放。</p>
<p>由于这些原因，最好在可能的地方使用确切的名称。例如，如果服务器最常请求的名称是<code>example.org</code>和<code>www.example.org</code>，则显式定义它们将更有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.org  www.example.org  *.example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是使用简化形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  .example.org;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了大量服务器名称，或者定义了特别长的服务器名称，则可能有必要在http级别调整<strong>server_names_hash_max_size</strong>和<strong>server_names_hash_bucket_size</strong>指令。 <strong>server_names_hash_bucket_size</strong>伪指令的默认值可以等于32或64，或其他值，具体取决于CPU缓存行大小。如果默认值为32，并且服务器名称定义为<code>too.long.server.name.example.org</code>，则nginx将无法启动并显示错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">could not build the server_names_hash,</span><br><span class="line">you should increase server_names_hash_bucket_size: 32</span><br></pre></td></tr></table></figure>
<p>在这种情况下，应将指令值增加到下一个二次幂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server_names_hash_bucket_size  64;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了大量服务器名称，则会出现另一条错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">could not build the server_names_hash,</span><br><span class="line">you should increase either server_names_hash_max_size: 512</span><br><span class="line">or server_names_hash_bucket_size: 32</span><br></pre></td></tr></table></figure>
<p>在这种情况下，请首先尝试将<strong>server_names_hash_max_size</strong>设置为接近服务器名称数量的数字。仅当这无济于事或nginx的启动时间过长而无法接受时，请尝试增加<strong>server_names_hash_bucket_size</strong>。<br>如果服务器是侦听端口的唯一服务器，则nginx根本不会测试服务器名称(并且不会为侦听端口构建哈希表)。但是，有一个例外。如果服务器名称是带有捕获的正则表达式，则nginx必须执行该表达式以获取捕获。</p>
<h3 id="Compatibility-兼容性"><a href="#Compatibility-兼容性" class="headerlink" title="Compatibility 兼容性"></a>Compatibility 兼容性</h3><ul>
<li>从0.9.4开始，支持特殊服务器名称<code>$hostname</code>。</li>
<li>从0.8.48开始，默认的服务器名称值为空名称””。</li>
<li>从0.8.25开始，支持命名正则表达式服务器名称捕获。</li>
<li>从0.7.40开始，支持正则表达式服务器名称捕获。</li>
<li>从0.7.12开始，支持空服务器名称””。</li>
<li>从0.6.25开始，支持使用通配符服务器名称或正则表达式作为第一个服务器名称。</li>
<li>从0.6.7开始，支持正则表达式服务器名称。</li>
<li>从0.6.0开始，支持通配符形式<code>example.*</code>。</li>
<li>从0.3.18开始，支持特殊格式<code>.example.org</code>。</li>
<li>从0.1.13开始，支持通配符格式<code>*.example.org</code>。</li>
</ul>
</div><div class="tags"></div></section></div><div class="container"><ul class="nav"><li>下一篇：<a href="/2020/04/28/hello-world/">Hello World</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><div> <a href="http://www.beian.miit.gov.cn/" target="_blank">粤ICP备20040793号</a></div><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>

<script src="/script/post.js"></script>
</body></html>